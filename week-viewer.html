<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week Viewer - Lectern</title>
    <link rel="stylesheet" href="styles/lectern-core.css">
    <script src="js/db-schema.js"></script>
    <script src="js/validation.js"></script>
    <script src="js/rich-text.js"></script>
    <style>
        .user-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.5rem 1rem;
            background: var(--light-bg);
            border-bottom: 1px solid #e9ecef;
        }
        .user-header .user-info { flex: 1; }
        .user-header .admin-badge {
            background: var(--primary-color);
            color: white;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 500;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            margin-left: 0.5rem;
        }
        /* Loading state styles */
        .page-loading {
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .page-loaded {
            opacity: 1;
        }
        .loading-spinner {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 4rem 2rem;
            color: #6c757d;
        }
        .loading-spinner::before {
            content: '';
            width: 40px;
            height: 40px;
            border: 3px solid #e9ecef;
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-bottom: 1rem;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        /* Discussion textarea styles */
        .discussion-section textarea,
        textarea[id^="response-"],
        textarea[id^="reply-text-"],
        textarea[id^="post-edit-text-"],
        textarea[id^="reply-edit-text-"] {
            font-family: 'Benton Sans', Arial, sans-serif;
            font-size: 0.95rem;
            line-height: 1.6;
            letter-spacing: 0.01em;
            padding: 0.875rem;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            resize: vertical;
            transition: border-color 0.2s ease;
            background: #fff;
        }
        .discussion-section textarea:focus,
        textarea[id^="response-"]:focus,
        textarea[id^="reply-text-"]:focus,
        textarea[id^="post-edit-text-"]:focus,
        textarea[id^="reply-edit-text-"]:focus {
            outline: none;
            border-color: var(--teal);
            box-shadow: 0 0 0 3px rgba(16, 100, 112, 0.1);
        }
        .discussion-section textarea::placeholder,
        textarea[id^="response-"]::placeholder,
        textarea[id^="reply-text-"]::placeholder {
            color: #9ca3af;
            letter-spacing: 0.01em;
        }
        /* Text button styles for discussion actions */
        .btn-text {
            background: none;
            border: none;
            font-size: 0.8rem;
            cursor: pointer;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            transition: background 0.15s;
            font-family: inherit;
        }
        .btn-text:hover { background: rgba(0,0,0,0.05); }
        .btn-text.teal { color: var(--teal); }
        .btn-text.olive { color: #7a7d4e; }
        .btn-text.gold { color: #b8860b; }
        .btn-text.red { color: #a21f35; }
        /* Collapse toggle hover */
        .collapse-toggle:hover { color: var(--teal) !important; }
    </style>
</head>
<body>
    <div id="user-header" class="user-header" style="display: none;"></div>

    <header>
        <div class="header-content">
            <a href="index.html" class="logo" style="text-decoration: none; color: inherit;">
                <img src="brand-assets/aquinas-logo.svg" alt="Aquinas Institute" class="logo-icon">
                <h1>Lectern</h1>
            </a>
            <div id="header-actions"></div>
        </div>
    </header>

    <!-- Loading State -->
    <div id="loading-state" class="container">
        <div class="loading-spinner">Loading week content...</div>
    </div>

    <!-- Main Content (hidden until loaded) -->
    <div id="main-content" class="container page-loading">
        <div class="breadcrumb">
            <a href="index.html">Home</a>
            <span>›</span>
            <a href="module-overview.html">Module Overview</a>
            <span>›</span>
            <span id="breadcrumb-week">Week</span>
        </div>

        <h2 class="page-title">
            <span id="page-title">Loading...</span>
        </h2>

        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
        <p style="text-align: center; color: #9ca3af; font-size: 0.85rem; letter-spacing: 0.02em; margin-bottom: 2rem;" id="progress-text">Page 1 of 5</p>

        <!-- Page Content Container -->
        <div id="page-content"></div>

        <!-- Navigation -->
        <div style="display: flex; justify-content: space-between; margin-top: 2rem;">
            <div style="display: flex; gap: 1rem;">
                <button class="btn-f olive" type="button" onclick="goToModuleOverview()">← Back to Module Overview</button>
                <button class="btn-f olive" type="button" id="prev-btn" onclick="previousPage()" style="display: none;">← Previous</button>
            </div>
            <div style="display: flex; gap: 1rem;">
                <button class="btn-f olive" type="button" id="save-exit-btn" onclick="saveProgressAndExit()" style="display: none;">Save Progress & Exit</button>
                <button class="btn-f gold" type="button" id="next-btn" onclick="nextPage()">Next →</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { dataService } from './js/data-service-supabase.js';
        import { requireActiveUser, logout, canAccessModule } from './js/auth.js';

        let currentView = 'student';
        let currentWeek = null;
        let currentPage = 1;
        let currentModuleId = null;
        let isParticipantMode = false;
        let isPreviewMode = false;
        let currentUser = null;

        function renderUserHeader() {
            const header = document.getElementById('user-header');
            const isAdmin = currentUser.role === 'admin';

            header.innerHTML = `
                <span class="user-info">
                    <strong>${currentUser.name || currentUser.email}</strong>
                    ${isAdmin ? '<span class="admin-badge">Admin</span>' : ''}
                </span>
                ${isAdmin ? '<a href="admin-users.html" class="btn-f olive" style="padding: 0.5rem 1rem; font-size: 0.85rem;">Manage Users</a>' : ''}
                <button onclick="logoutUser()" class="btn-f olive" style="padding: 0.5rem 1rem; font-size: 0.85rem;">Logout</button>
            `;
            header.style.display = 'flex';
        }
        let totalPages = 6; // Now 6 pages with Zoom Prep

        // Convert video URLs to embed URLs
        function getVideoEmbedUrl(url) {
            if (!url) return null;

            // YouTube URL patterns
            const youtubeRegex = /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]+)/;
            const youtubeMatch = url.match(youtubeRegex);
            if (youtubeMatch) {
                return `https://www.youtube.com/embed/${youtubeMatch[1]}`;
            }

            // Vimeo URL patterns
            const vimeoRegex = /vimeo\.com\/(\d+)/;
            const vimeoMatch = url.match(vimeoRegex);
            if (vimeoMatch) {
                return `https://player.vimeo.com/video/${vimeoMatch[1]}`;
            }

            // If already an embed URL, return it
            if (url.includes('youtube.com/embed/') || url.includes('player.vimeo.com/video/')) {
                return url;
            }

            // Not a supported video platform
            return null;
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            if (!text) return '';
            return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }

        // Generate consistent color for author name
        const authorColors = {};
        const colorPalette = [
            '#2563eb', // blue
            '#059669', // emerald
            '#7c3aed', // violet
            '#db2777', // pink
            '#ea580c', // orange
            '#0891b2', // cyan
            '#4f46e5', // indigo
            '#16a34a', // green
            '#9333ea', // purple
            '#dc2626', // red
            '#0d9488', // teal
            '#ca8a04', // yellow
        ];
        function getAuthorColor(authorName) {
            if (!authorName) return colorPalette[0];
            if (authorColors[authorName]) return authorColors[authorName];

            // Simple hash of author name to pick a consistent color
            let hash = 0;
            for (let i = 0; i < authorName.length; i++) {
                hash = ((hash << 5) - hash) + authorName.charCodeAt(i);
                hash = hash & hash;
            }
            const colorIndex = Math.abs(hash) % colorPalette.length;
            authorColors[authorName] = colorPalette[colorIndex];
            return authorColors[authorName];
        }

        // Format text with basic markdown support (line breaks, bullet points)
        function formatText(text) {
            if (!text) return '';

            // Check if content contains HTML tags (rich text from editor)
            const hasHTML = /<[^>]+>/.test(text);

            if (hasHTML) {
                // Clean the HTML using RichText utility if available
                let cleaned = typeof RichText !== 'undefined' ? RichText.cleanPastedHTML(text) : text;

                // Ensure links open in new tab and have proper styling
                cleaned = cleaned.replace(/<a\s+href="([^"]*)"(?![^>]*target)/gi, '<a href="$1" target="_blank" style="color: var(--teal); text-decoration: underline;"');

                // Style lists
                cleaned = cleaned.replace(/<ul>/gi, '<ul style="margin: 0.5rem 0; padding-left: 1.5rem;">');
                cleaned = cleaned.replace(/<ol>/gi, '<ol style="margin: 0.5rem 0; padding-left: 1.5rem;">');

                return cleaned;
            }

            // Plain text fallback - escape HTML and convert line breaks
            const escaped = text.replace(/</g, '&lt;').replace(/>/g, '&gt;');
            let formatted = escaped.replace(/\n/g, '<br>');

            // Convert markdown-style bullets to HTML list items
            const lines = formatted.split('<br>');
            let inList = false;
            let result = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                const isBullet = /^[\*\-\•]\s/.test(line);

                if (isBullet) {
                    if (!inList) {
                        result.push('<ul style="margin: 0.5rem 0; padding-left: 1.5rem;">');
                        inList = true;
                    }
                    const content = line.replace(/^[\*\-\•]\s/, '');
                    result.push(`<li>${content}</li>`);
                } else {
                    if (inList) {
                        result.push('</ul>');
                        inList = false;
                    }
                    result.push(line + '<br>');
                }
            }

            if (inList) {
                result.push('</ul>');
            }

            return result.join('');
        }

        async function setView(view, fromToggle = false) {
            // Only redirect to index.html if explicitly toggling to student view (not on page load)
            if (view === 'student' && fromToggle) {
                dataService.setCurrentView('student');
                window.location.href = 'index.html';
                return;
            }

            currentView = view;

            if (view === 'student') {
                dataService.setCurrentView('student');
            } else {
                dataService.setCurrentView('admin');
            }
            // Note: renderPage is called after loadWeekData in onload
        }

        function getWeekIdFromURL() {
            const params = new URLSearchParams(window.location.search);
            return parseInt(params.get('week'));
        }

        function getPageFromURL() {
            const params = new URLSearchParams(window.location.search);
            return parseInt(params.get('page')) || 1;
        }

        async function loadWeekData() {
            const weekId = getWeekIdFromURL();

            // Load weeks using DataService
            currentModuleId = dataService.getCurrentModuleId();
            if (currentModuleId) {
                currentWeek = await dataService.getWeek(currentModuleId, weekId);
            }

            if (!currentWeek) {
                document.getElementById('page-content').innerHTML = '<p style="text-align: center; color: #dc3545; padding: 2rem;">Week not found.</p>';
                return false;
            }

            currentPage = getPageFromURL();
            updateBreadcrumb();
            return true;
        }

        function updateBreadcrumb() {
            document.getElementById('breadcrumb-week').textContent = `Week ${currentWeek.id}: ${currentWeek.title}`;
        }

        function updateProgress() {
            const progress = (currentPage / totalPages) * 100;
            document.getElementById('progress-fill').style.width = progress + '%';
            document.getElementById('progress-text').textContent = `Page ${currentPage} of ${totalPages}`;
        }

        async function renderPage() {
            if (!currentWeek) {
                return;
            }

            const pageData = currentWeek.pages[currentPage - 1];
            if (!pageData) {
                document.getElementById('page-content').innerHTML = '<p style="text-align: center; color: #dc3545;">Page data not found.</p>';
                return;
            }

            document.getElementById('page-title').textContent = pageData.title;
            updateProgress();

            const content = document.getElementById('page-content');

            // Render based on page type
            if (pageData.type === 'discussion') {
                await renderDiscussionPage(pageData, content);
            } else if (pageData.type === 'intro') {
                renderIntroPage(pageData, content);
            } else if (pageData.type === 'reading') {
                renderReadingPage(pageData, content);
            }

            // Update navigation buttons
            document.getElementById('prev-btn').style.display = currentPage === 1 ? 'none' : 'block';
            document.getElementById('next-btn').textContent = currentPage === totalPages ? 'Finish →' : 'Next →';

            // Show Save Progress & Exit button only for students (not on last page)
            const saveExitBtn = document.getElementById('save-exit-btn');
            if (currentView === 'student' && currentPage < totalPages) {
                saveExitBtn.style.display = 'block';
            } else {
                saveExitBtn.style.display = 'none';
            }
        }

        async function renderDiscussionPage(pageData, container) {
            const questions = pageData.questions || [];
            const pageIndex = currentPage - 1;

            // Determine read-only based on module status, participant mode, and preview mode
            // Read-only when: archived, OR preview mode, OR draft without participant mode
            // Full read/write when: launched (not preview), OR draft WITH participant mode (admin simulating student)
            const module = await dataService.getModule(currentModuleId);
            const moduleStatus = module ? module.status : 'draft';
            const isReadOnly = moduleStatus === 'archived' || isPreviewMode || (moduleStatus === 'draft' && !isParticipantMode);

            let html = '<div class="card" style="width: 100%;">';

            // Show read-only notice
            if (isReadOnly) {
                let noticeText;
                if (moduleStatus === 'archived') {
                    noticeText = '<strong>Archived Module:</strong> This module is archived. Discussion posts and replies are disabled.';
                } else if (isPreviewMode) {
                    noticeText = '<strong>Preview Mode:</strong> This is a read-only preview. Use Participant Mode to test discussions.';
                } else {
                    noticeText = '<strong>Preview Mode:</strong> This is a read-only preview for testing links and embeds. Use Participant Mode to test discussions.';
                }
                html += `<div style="background: #fff3cd; border: 1px solid #ffc107; padding: 0.75rem; margin-bottom: 1rem; border-radius: 4px; font-size: 0.9rem;">
                    ${noticeText}
                </div>`;
            }

            if (questions.length > 0) {
                for (let index = 0; index < questions.length; index++) {
                    const question = questions[index];

                    // Show discussion thread for everyone (isolated per module)
                    const posts = await dataService.getDiscussionPosts(currentModuleId, currentWeek.id, pageIndex, index);

                    // Open question box - teal bordered wrapper with card inside
                    html += `
                        <div style="background: transparent; border: 2px solid var(--teal); border-radius: 16px; padding: 1.75rem; margin-bottom: 3rem; position: relative;">
                            <h3 style="position: absolute; top: -0.7rem; left: 1.5rem; background: #f8f9fa; padding: 0 0.75rem; font-size: 1rem; color: var(--teal); margin: 0;">Question ${index + 1}</h3>
                            <div style="background: white; border-radius: 12px; overflow: hidden; border: 1px solid #e5e7eb;">
                                <div style="background: #d5dde0; padding: 1rem 1.25rem;">
                                    <div style="font-family: 'Adobe Garamond Pro', Georgia, serif; font-size: 1.2rem; font-style: italic; color: #2c3e50; line-height: 1.5; margin: 0;">${question.text}</div>
                                </div>
                    `;

                    // Show input form when module is launched (not read-only)
                    if (!isReadOnly) {
                        html += `
                                <div style="padding: 1.5rem;">
                                    <textarea id="response-${index}" placeholder="Share your thoughts on this question..." style="min-height: 120px; width: 100%; padding: 0.875rem; border: 1px solid #d1d5db; border-radius: 6px; font-family: 'Benton Sans', Arial, sans-serif; font-size: 0.95rem; resize: vertical; transition: border-color 0.2s ease;"></textarea>
                                    <div style="display: flex; justify-content: flex-end; margin-top: 1rem;">
                                        <button class="btn-f teal" onclick="postDiscussion(${index})">Post Response</button>
                                    </div>
                                </div>
                            </div>
                            <div class="discussion-section" style="margin-top: 1.5rem;">
                                <div id="discussion-thread-${index}">
                                    ${renderDiscussionThread(posts, pageIndex, index, false, currentUser.id)}
                                </div>
                            </div>
                        `;
                    } else {
                        // Read-only mode (draft preview or archived) - show threads but no input, close the card
                        html += `
                            </div>
                            <div class="discussion-section" style="margin-top: 1.5rem;">
                                <div id="discussion-thread-${index}">
                                    ${renderDiscussionThread(posts, pageIndex, index, true, currentUser.id)}
                                </div>
                            </div>
                        `;
                    }

                    // Close question wrapper
                    html += '</div>';

                    if (index < questions.length - 1) {
                        html += '<hr style="margin: 2rem 0;">';
                    }
                }
            } else {
                html += '<p style="color: #6c757d; text-align: center;">No questions available for this discussion.</p>';
            }

            html += '</div>';
            container.innerHTML = html;

            // Initialize rich text on all textareas
            setTimeout(() => {
                RichText.initAll('textarea[id^="response-"], textarea[id^="reply-text-"], textarea[id^="post-edit-text-"], textarea[id^="reply-edit-text-"]');
            }, 0);
        }

        function renderDiscussionThread(posts, pageIndex, questionIndex, readOnly = false, currentUserId = null) {
            if (!posts || posts.length === 0) {
                const msg = readOnly ? 'No discussion posts yet.' : 'No discussion posts yet. Be the first to share!';
                return `<p style="color: #6c757d; font-style: italic; margin-top: 1rem;">${msg}</p>`;
            }

            let html = '<div class="discussion-thread">';
            posts.forEach(post => {
                const postDate = new Date(post.createdAt).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                const postTime = new Date(post.createdAt).toLocaleTimeString([], {hour: 'numeric', minute:'2-digit'});
                const isOwnPost = currentUserId && post.userId === currentUserId;
                const editedText = post.editedAt ? ' <span style="font-size: 0.75rem; color: #9ca3af;">(edited)</span>' : '';
                const postAuthorColor = getAuthorColor(post.author);
                const replyCount = post.replies ? post.replies.length : 0;

                html += `
                    <div class="thread-post" style="padding: 1rem 0; border-bottom: 1px solid #f0f0f0;">
                        <div style="display: flex; align-items: baseline; gap: 0.5rem; margin-bottom: 0.25rem;">
                            <span style="font-weight: 500; letter-spacing: 0.02em; color: ${postAuthorColor};">${escapeHtml(post.author) || 'Anonymous'}${editedText}</span>
                            <span style="color: #9ca3af; font-size: 0.8rem; letter-spacing: 0.02em;">${postDate} at ${postTime}</span>
                        </div>
                        <div id="post-content-${post.id}">
                            <div style="margin: 0.5rem 0; color: #333; line-height: 1.7;">${RichText.toHTML(post.content)}</div>
                        </div>
                        <div id="post-edit-form-${post.id}" style="display: none; margin-top: 0.5rem;">
                            <textarea id="post-edit-text-${post.id}" style="width: 100%; min-height: 100px; margin-bottom: 0.5rem; padding: 0.75rem; border: 1px solid #ddd; border-radius: 6px; font-family: 'Benton Sans', Arial, sans-serif; font-size: 0.95rem;">${escapeHtml(post.content)}</textarea>
                            <div style="display: flex; justify-content: flex-end; gap: 0.5rem;">
                                <button class="btn-text teal" onclick="savePostEdit(${pageIndex}, ${questionIndex}, ${post.id})">Save</button>
                                <button class="btn-text olive" onclick="cancelPostEdit(${post.id})">Cancel</button>
                            </div>
                        </div>
                `;

                // Action buttons
                if (!readOnly) {
                    html += `<div id="post-actions-${post.id}" style="display: flex; gap: 0.25rem; margin-top: 0.5rem;">
                            <button class="btn-text teal" onclick="toggleReplyForm(${post.id})">Reply</button>`;
                    if (isOwnPost) {
                        html += `
                            <button class="btn-text gold" onclick="editPost(${post.id})">Edit</button>
                            <button class="btn-text red" onclick="deletePost(${post.id})">Delete</button>`;
                    }
                    html += `</div>`;
                }

                // Replies section (shown by default)
                if (replyCount > 0) {
                    html += `
                        <button class="collapse-toggle" onclick="toggleRepliesCollapse(this)" style="background: none; border: none; color: #888; font-size: 0.8rem; cursor: pointer; display: flex; align-items: center; gap: 0.25rem; padding: 0.5rem 0; margin-top: 0.5rem;">
                            <span class="arrow" style="transition: transform 0.2s; font-size: 0.7rem;">&#9660;</span>
                            <span class="reply-count">Hide replies</span>
                        </button>
                        <div class="replies-container" style="margin-left: 1.5rem; padding-left: 1rem; border-left: 2px solid #e8e8e8;">
                    `;

                    post.replies.forEach(reply => {
                        const replyDate = new Date(reply.createdAt).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                        const replyTime = new Date(reply.createdAt).toLocaleTimeString([], {hour: 'numeric', minute:'2-digit'});
                        const replyEditedText = reply.editedAt ? ' <span style="font-size: 0.7rem; color: #9ca3af;">(edited)</span>' : '';
                        const replyAuthorColor = getAuthorColor(reply.author);
                        const isOwnReply = currentUserId && reply.userId === currentUserId;

                        html += `
                            <div class="thread-reply" style="padding: 0.75rem 0;">
                                <div style="display: flex; align-items: baseline; gap: 0.5rem; margin-bottom: 0.25rem;">
                                    <span style="font-weight: 500; letter-spacing: 0.02em; color: ${replyAuthorColor}; font-size: 0.9rem;">${escapeHtml(reply.author) || 'Anonymous'}${replyEditedText}</span>
                                    <span style="color: #9ca3af; font-size: 0.8rem; letter-spacing: 0.02em;">${replyDate} at ${replyTime}</span>
                                </div>
                                <div id="reply-content-${reply.id}">
                                    <div style="margin: 0; font-size: 0.9rem; color: #444; line-height: 1.7;">${RichText.toHTML(reply.content)}</div>
                                </div>
                                <div id="reply-edit-form-${reply.id}" style="display: none; margin-top: 0.5rem;">
                                    <textarea id="reply-edit-text-${reply.id}" style="width: 100%; min-height: 70px; margin-bottom: 0.5rem; padding: 0.75rem; border: 1px solid #ddd; border-radius: 6px; font-family: 'Benton Sans', Arial, sans-serif; font-size: 0.9rem;">${escapeHtml(reply.content)}</textarea>
                                    <div style="display: flex; justify-content: flex-end; gap: 0.5rem;">
                                        <button class="btn-text teal" onclick="saveReplyEdit(${pageIndex}, ${questionIndex}, ${post.id}, ${reply.id})">Save</button>
                                        <button class="btn-text olive" onclick="cancelReplyEdit(${reply.id})">Cancel</button>
                                    </div>
                                </div>
                                ${!readOnly ? `
                                    <div id="reply-actions-${reply.id}" style="display: flex; gap: 0.25rem; margin-top: 0.25rem;">
                                        <button class="btn-text teal" onclick="toggleReplyForm(${post.id})">Reply</button>
                                        ${isOwnReply ? `
                                            <button class="btn-text gold" onclick="editReply(${reply.id})">Edit</button>
                                            <button class="btn-text red" onclick="deleteReply(${reply.id})">Delete</button>
                                        ` : ''}
                                    </div>
                                ` : ''}
                            </div>
                        `;
                    });
                    html += '</div>';
                }

                // Reply form (placed after replies so it appears at bottom of thread)
                if (!readOnly) {
                    html += `
                        <div id="reply-form-${post.id}" style="display: none; margin-top: 1rem; margin-left: 1.5rem; padding-left: 1rem; border-left: 2px solid #e8e8e8;">
                            <textarea id="reply-text-${post.id}" placeholder="Write your reply..." style="width: 100%; min-height: 80px; margin-bottom: 0.5rem; padding: 0.75rem; border: 1px solid #ddd; border-radius: 6px; font-family: 'Benton Sans', Arial, sans-serif; font-size: 0.9rem;"></textarea>
                            <div style="display: flex; justify-content: flex-end; gap: 0.5rem;">
                                <button class="btn-text teal" onclick="postReply(${pageIndex}, ${questionIndex}, ${post.id})">Post Reply</button>
                                <button class="btn-text olive" onclick="toggleReplyForm(${post.id})">Cancel</button>
                            </div>
                        </div>
                    `;
                }

                html += '</div>';
            });
            html += '</div>';

            return html;
        }

        function toggleRepliesCollapse(btn) {
            const container = btn.nextElementSibling;
            if (container && container.classList.contains('replies-container')) {
                const isCollapsed = container.style.display === 'none';
                container.style.display = isCollapsed ? 'block' : 'none';
                btn.classList.toggle('collapsed', !isCollapsed);
                const arrow = btn.querySelector('.arrow');
                if (arrow) {
                    arrow.style.transform = isCollapsed ? 'rotate(0deg)' : 'rotate(-90deg)';
                }
                const countSpan = btn.querySelector('.reply-count');
                if (countSpan) {
                    const text = countSpan.textContent;
                    if (isCollapsed) {
                        // Showing replies: change "View X replies" to "Hide replies"
                        countSpan.textContent = 'Hide replies';
                    } else {
                        // Hiding replies: extract count and show "View X replies"
                        const replyCount = container.querySelectorAll('.thread-reply').length;
                        countSpan.textContent = `View ${replyCount} ${replyCount === 1 ? 'reply' : 'replies'}`;
                    }
                }
            }
        }

        function renderIntroPage(pageData, container) {
            let html = `
                <div style="background: transparent; border: 2px solid var(--teal); border-radius: 16px; padding: 1.75rem; position: relative;">
                    <h3 style="position: absolute; top: -0.7rem; left: 1.5rem; background: #f8f9fa; padding: 0 0.75rem; font-size: 1rem; color: var(--teal); margin: 0;">${pageData.title}</h3>
            `;

            // Show intro text
            if (pageData.content) {
                html += `<div style="margin-top: 1rem; width: 100%;">${formatText(pageData.content)}</div>`;
            }

            // Show videos if any
            const videos = pageData.videos || [];
            if (videos.length > 0) {
                html += '<div class="video-playlist" style="margin-top: 2rem;">';
                videos.forEach(video => {
                    const durationText = video.duration ? ` (${video.duration})` : '';
                    const embedUrl = getVideoEmbedUrl(video.url);
                    const cardLabel = embedUrl ? 'Video' : 'Resource';

                    html += `
                        <div style="background: white; border-radius: 12px; overflow: hidden; border: 1px solid #e5e7eb; margin-bottom: 1rem;">
                            <div style="background: #d5dde0; padding: 0.75rem 1.25rem;">
                                <span style="font-family: 'Adobe Garamond Pro', Georgia, serif; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.1em; color: var(--teal); font-weight: 400;">${cardLabel}</span>
                            </div>
                            <div style="padding: 1.25rem;">
                                ${embedUrl ? `
                                    <strong style="display: block; margin-bottom: 1rem;">${video.title}${durationText}</strong>
                                    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
                                        <iframe src="${embedUrl}" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 0;" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                                    </div>
                                ` : `
                                    <div style="display: flex; justify-content: space-between; align-items: center; gap: 1rem;">
                                        <strong>${video.title}${durationText}</strong>
                                        <a href="${video.url}" target="_blank" class="btn-f teal" style="padding: 0.4rem 0.8rem; font-size: 0.85rem; text-decoration: none; white-space: nowrap;">View Resource</a>
                                    </div>
                                `}
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
            }

            html += '</div>';
            container.innerHTML = html;
        }

        function renderReadingPage(pageData, container) {
            const resources = pageData.resources || [];
            const videos = pageData.videos || [];

            let html = '<div class="card">';
            html += `<h3>${pageData.title}</h3>`;

            if (resources.length === 0 && videos.length === 0) {
                html += '<p style="color: #6c757d; text-align: center; padding: 2rem;">No resources available yet.</p>';
            } else {
                if (resources.length > 0) {
                    html += '<div class="resource-list" style="margin-top: 1.5rem;">';
                    resources.forEach(resource => {
                        const hasUrl = resource.url && resource.url.trim();
                        html += `
                            <div style="background: white; border-radius: 12px; overflow: hidden; border: 1px solid #e5e7eb; margin-bottom: 1rem;">
                                <div style="background: #d5dde0; padding: 0.75rem 1.25rem;">
                                    <span style="font-family: 'Adobe Garamond Pro', Georgia, serif; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.1em; color: var(--teal); font-weight: 400;">Resource</span>
                                </div>
                                <div style="padding: 1.25rem;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; gap: 1rem;">
                                        <strong>${resource.title}</strong>
                                        ${hasUrl ? `<a href="${resource.url}" target="_blank" class="btn-f teal" style="padding: 0.4rem 0.8rem; font-size: 0.85rem; text-decoration: none; white-space: nowrap;">View Resource</a>` : ''}
                                    </div>
                                    ${resource.description ? `<p style="color: #6c757d; margin-top: 0.5rem; line-height: 1.5; margin-bottom: 0;">${formatText(resource.description)}</p>` : ''}
                                </div>
                            </div>
                        `;
                    });
                    html += '</div>';
                }

                if (videos.length > 0) {
                    html += '<div class="video-playlist" style="margin-top: 1.5rem;">';
                    videos.forEach(video => {
                        const durationText = video.duration ? ` (${video.duration})` : '';
                        const embedUrl = getVideoEmbedUrl(video.url);
                        const cardLabel = embedUrl ? 'Video' : 'Resource';

                        html += `
                            <div style="background: white; border-radius: 12px; overflow: hidden; border: 1px solid #e5e7eb; margin-bottom: 1rem;">
                                <div style="background: #d5dde0; padding: 0.75rem 1.25rem;">
                                    <span style="font-family: 'Adobe Garamond Pro', Georgia, serif; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.1em; color: var(--teal); font-weight: 400;">${cardLabel}</span>
                                </div>
                                <div style="padding: 1.25rem;">
                                    ${embedUrl ? `
                                        <strong style="display: block; margin-bottom: 1rem;">${video.title}${durationText}</strong>
                                        <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
                                            <iframe src="${embedUrl}" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 0;" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                                        </div>
                                    ` : `
                                        <div style="display: flex; justify-content: space-between; align-items: center; gap: 1rem;">
                                            <strong>${video.title}${durationText}</strong>
                                            <a href="${video.url}" target="_blank" class="btn-f teal" style="padding: 0.4rem 0.8rem; font-size: 0.85rem; text-decoration: none; white-space: nowrap;">View Resource</a>
                                        </div>
                                    `}
                                </div>
                            </div>
                        `;
                    });
                    html += '</div>';
                }
            }

            html += '</div>';
            container.innerHTML = html;
        }

        async function postDiscussion(questionIndex) {
            const textarea = document.getElementById(`response-${questionIndex}`);
            const content = textarea.value.trim();

            if (!content) {
                showNotification('Please enter a response before posting.', 'error');
                return;
            }

            // Use logged-in user's name
            const author = currentUser.name || currentUser.email || 'Anonymous';

            // Add discussion post using DataService (isolated per module)
            const pageIndex = currentPage - 1; // Convert to 0-based index
            await dataService.addDiscussionPost(currentModuleId, currentWeek.id, pageIndex, questionIndex, {
                author: author,
                content: content
            });

            showNotification('Response posted!', 'success');
            textarea.value = '';

            // Reload the page to show the new post
            await renderPage();
        }

        // Close all open edit/reply forms to keep UI clean
        function closeAllEditForms() {
            // Close all post edit forms
            document.querySelectorAll('[id^="post-edit-form-"]').forEach(form => {
                if (form.style.display !== 'none') {
                    const postId = form.id.replace('post-edit-form-', '');
                    const contentEl = document.getElementById(`post-content-${postId}`);
                    const actionsEl = document.getElementById(`post-actions-${postId}`);
                    if (contentEl) contentEl.style.display = 'block';
                    form.style.display = 'none';
                    if (actionsEl) actionsEl.style.display = 'flex';
                }
            });
            // Close all reply edit forms
            document.querySelectorAll('[id^="reply-edit-form-"]').forEach(form => {
                if (form.style.display !== 'none') {
                    const replyId = form.id.replace('reply-edit-form-', '');
                    const contentEl = document.getElementById(`reply-content-${replyId}`);
                    const actionsEl = document.getElementById(`reply-actions-${replyId}`);
                    if (contentEl) contentEl.style.display = 'block';
                    form.style.display = 'none';
                    if (actionsEl) actionsEl.style.display = 'flex';
                }
            });
            // Close all reply forms (new reply)
            document.querySelectorAll('[id^="reply-form-"]').forEach(form => {
                form.style.display = 'none';
            });
        }

        function toggleReplyForm(postId) {
            const replyForm = document.getElementById(`reply-form-${postId}`);
            const isCurrentlyOpen = replyForm.style.display !== 'none';

            // Close all other forms first
            closeAllEditForms();

            // Toggle this one (if it was open, it's now closed; if closed, open it)
            if (!isCurrentlyOpen) {
                replyForm.style.display = 'block';
            }
        }

        async function postReply(pageIndex, questionIndex, postId) {
            const textarea = document.getElementById(`reply-text-${postId}`);
            const content = textarea.value.trim();

            if (!content) {
                showNotification('Please enter a reply before posting.', 'error');
                return;
            }

            // Use logged-in user's name
            const author = currentUser.name || currentUser.email || 'Anonymous';

            // Add reply using DataService (isolated per module)
            await dataService.addReply(currentModuleId, currentWeek.id, pageIndex, questionIndex, postId, {
                author: author,
                content: content
            });

            showNotification('Reply posted!', 'success');

            // Reload the page to show the new reply
            await renderPage();
        }

        function editPost(postId) {
            // Close all other edit/reply forms first
            closeAllEditForms();

            document.getElementById(`post-content-${postId}`).style.display = 'none';
            document.getElementById(`post-edit-form-${postId}`).style.display = 'block';
            const actionsEl = document.getElementById(`post-actions-${postId}`);
            if (actionsEl) actionsEl.style.display = 'none';
        }

        function cancelPostEdit(postId) {
            document.getElementById(`post-content-${postId}`).style.display = 'block';
            document.getElementById(`post-edit-form-${postId}`).style.display = 'none';
            const actionsEl = document.getElementById(`post-actions-${postId}`);
            if (actionsEl) actionsEl.style.display = 'flex';
        }

        async function savePostEdit(pageIndex, questionIndex, postId) {
            const textarea = document.getElementById(`post-edit-text-${postId}`);
            const content = textarea.value.trim();

            if (!content) {
                showNotification('Post content cannot be empty.', 'error');
                return;
            }

            await dataService.editDiscussionPost(currentModuleId, currentWeek.id, pageIndex, questionIndex, postId, content);
            showNotification('Post updated!', 'success');
            await renderPage();
        }

        function editReply(replyId) {
            // Close all other edit/reply forms first
            closeAllEditForms();

            document.getElementById(`reply-content-${replyId}`).style.display = 'none';
            document.getElementById(`reply-edit-form-${replyId}`).style.display = 'block';
            const actionsEl = document.getElementById(`reply-actions-${replyId}`);
            if (actionsEl) actionsEl.style.display = 'none';
        }

        function cancelReplyEdit(replyId) {
            document.getElementById(`reply-content-${replyId}`).style.display = 'block';
            document.getElementById(`reply-edit-form-${replyId}`).style.display = 'none';
            const actionsEl = document.getElementById(`reply-actions-${replyId}`);
            if (actionsEl) actionsEl.style.display = 'flex';
        }

        async function saveReplyEdit(pageIndex, questionIndex, postId, replyId) {
            const textarea = document.getElementById(`reply-edit-text-${replyId}`);
            const content = textarea.value.trim();

            if (!content) {
                showNotification('Reply content cannot be empty.', 'error');
                return;
            }

            await dataService.editReply(currentModuleId, currentWeek.id, pageIndex, questionIndex, postId, replyId, content);
            showNotification('Reply updated!', 'success');
            await renderPage();
        }

        async function deletePost(postId) {
            if (!confirm('Are you sure you want to delete this post? All replies will also be deleted.')) {
                return;
            }

            try {
                await dataService.deleteDiscussionPost(postId);
                showNotification('Post deleted.', 'success');
                await renderPage();
            } catch (err) {
                showNotification('Failed to delete post: ' + err.message, 'error');
            }
        }

        async function deleteReply(replyId) {
            if (!confirm('Are you sure you want to delete this reply?')) {
                return;
            }

            try {
                await dataService.deleteReply(replyId);
                showNotification('Reply deleted.', 'success');
                await renderPage();
            } catch (err) {
                showNotification('Failed to delete reply: ' + err.message, 'error');
            }
        }

        // Helper to get week viewer URL (preserves participant mode)
        function getWeekViewerUrl(weekId, page) {
            const participantParam = isParticipantMode ? '&participant=true' : '';
            return `week-viewer.html?week=${weekId}&page=${page}${participantParam}`;
        }

        async function previousPage() {
            if (currentPage > 1) {
                currentPage--;
                // Auto-save position for students
                if (currentView === 'student' && currentModuleId) {
                    await dataService.savePagePosition(currentModuleId, currentWeek.id, currentPage);
                }
                window.location.href = getWeekViewerUrl(currentWeek.id, currentPage);
            }
        }

        async function nextPage() {
            if (currentPage < totalPages) {
                currentPage++;
                // Auto-save position for students
                if (currentView === 'student' && currentModuleId) {
                    await dataService.savePagePosition(currentModuleId, currentWeek.id, currentPage);
                }
                window.location.href = getWeekViewerUrl(currentWeek.id, currentPage);
            } else {
                // Finish - mark week as completed for students, just navigate for admins
                const currentView = dataService.getCurrentView();
                if (currentView === 'student' && currentModuleId) {
                    await dataService.completeWeek(currentModuleId, currentWeek.id);
                    showNotification('Week completed!', 'success');
                }
                // Short delay to let notification show before redirect
                setTimeout(() => {
                    window.location.href = getModuleOverviewUrl();
                }, 500);
            }
        }

        // Save progress when user leaves page (sync version for unload events)
        function saveProgressOnExit() {
            // Note: beforeunload cannot use async/await reliably
            // Progress is saved on each page navigation, so this is just a backup
            if (currentView === 'student' && currentModuleId && currentWeek) {
                // Use sendBeacon for reliable async save on unload if needed
                // For now, main progress saving happens on explicit navigation
            }
        }

        // Helper to get module overview URL (preserves participant mode)
        function getModuleOverviewUrl() {
            return isParticipantMode ? 'module-overview.html?participant=true' : 'module-overview.html';
        }

        // Navigate back to module overview
        function goToModuleOverview() {
            window.location.href = getModuleOverviewUrl();
        }

        // Explicit save and exit button handler
        async function saveProgressAndExit() {
            if (currentModuleId && currentWeek) {
                await dataService.savePagePosition(currentModuleId, currentWeek.id, currentPage);
            }
            showNotification('Progress saved!', 'success');
            // Short delay to let notification show before redirect
            setTimeout(() => {
                window.location.href = getModuleOverviewUrl();
            }, 500);
        }

        // Show content and hide loading spinner
        function showContent() {
            const loadingState = document.getElementById('loading-state');
            const mainContent = document.getElementById('main-content');

            loadingState.style.display = 'none';
            mainContent.classList.remove('page-loading');
            mainContent.classList.add('page-loaded');
        }

        // Show error and hide loading spinner
        function showError(message) {
            const loadingState = document.getElementById('loading-state');
            loadingState.innerHTML = `<p style="text-align: center; color: #dc3545; padding: 2rem;">${message}</p>`;
        }

        // Notification system (toast)
        function showNotification(message, type = 'info') {
            const existing = document.querySelector('.notification');
            if (existing) existing.remove();

            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 1rem 1.5rem;
                border-radius: 8px;
                color: white;
                font-weight: 500;
                z-index: 10000;
                animation: slideIn 0.3s ease;
                max-width: 400px;
            `;
            if (type === 'success') {
                notification.style.backgroundColor = 'rgba(16, 100, 112, 0.9)';
            } else if (type === 'error') {
                notification.style.backgroundColor = 'rgba(139, 26, 26, 0.9)';
            } else {
                notification.style.backgroundColor = 'rgba(115, 125, 78, 0.9)';
            }
            notification.style.backdropFilter = 'blur(10px)';

            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        window.onload = async function() {
            // Auth guard
            currentUser = await requireActiveUser();
            if (!currentUser) return;

            // Render user header
            renderUserHeader();

            // Check module access
            currentModuleId = dataService.getCurrentModuleId();
            if (currentModuleId && currentUser.role !== 'admin') {
                const hasAccess = await canAccessModule(currentUser, currentModuleId);
                if (!hasAccess) {
                    showNotification('You do not have access to this module.', 'error');
                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 1000);
                    return;
                }
            }

            // Check for participant mode and preview mode
            const urlParams = new URLSearchParams(window.location.search);
            isParticipantMode = urlParams.get('participant') === 'true';
            isPreviewMode = urlParams.get('preview') === 'true';

            // Determine view based on user role
            let savedView;
            if (currentUser.role === 'admin' && !isParticipantMode) {
                savedView = 'admin';
            } else {
                savedView = 'student';
            }

            // In participant mode, show banner
            if (isParticipantMode) {
                showParticipantModeBanner();
            }

            await setView(savedView);
            try {
                if (await loadWeekData()) {
                    await renderPage();
                    // Show content after everything is loaded
                    showContent();
                } else {
                    showError('Week not found.');
                }
            } catch (err) {
                console.error('Error loading week:', err);
                showError(`Error loading week: ${err.message}`);
            }
        };

        function showParticipantModeBanner() {
            const banner = document.createElement('div');
            banner.id = 'participant-mode-banner';
            banner.style.cssText = 'background: rgba(16, 100, 112, 0.15); color: #106470; padding: 1rem 1.5rem; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(16, 100, 112, 0.3);';
            banner.innerHTML = `
                <span style="font-family: \'Adobe Garamond Pro\', Georgia, serif; font-size: 1.05rem;"><strong>Participant Mode</strong> - You are viewing this module as a participant</span>
                <button class="btn-f teal" onclick="exitParticipantMode()">Exit to Admin View</button>
            `;
            const header = document.querySelector('header');
            header.insertAdjacentElement('afterend', banner);

            // Hide view toggle in participant mode
            const viewToggle = document.querySelector('.view-toggle');
            if (viewToggle) {
                viewToggle.style.display = 'none';
            }
        }

        function exitParticipantMode() {
            // Go back to module overview in admin view
            window.location.href = 'module-overview.html';
        }

        // Save progress when page is closed/navigated away
        window.addEventListener('beforeunload', saveProgressOnExit);
        window.addEventListener('pagehide', saveProgressOnExit);

        // Export functions to window for onclick handlers
        window.setView = setView;
        window.logoutUser = logout;
        window.exitParticipantMode = exitParticipantMode;
        window.previousPage = previousPage;
        window.nextPage = nextPage;
        window.goToModuleOverview = goToModuleOverview;
        window.saveProgressAndExit = saveProgressAndExit;
        window.postDiscussion = postDiscussion;
        window.toggleReplyForm = toggleReplyForm;
        window.postReply = postReply;
        window.editPost = editPost;
        window.cancelPostEdit = cancelPostEdit;
        window.savePostEdit = savePostEdit;
        window.editReply = editReply;
        window.cancelReplyEdit = cancelReplyEdit;
        window.saveReplyEdit = saveReplyEdit;
        window.deletePost = deletePost;
        window.deleteReply = deleteReply;
        window.toggleRepliesCollapse = toggleRepliesCollapse;
        window.dataService = dataService;
    </script>
</body>
</html>
